<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eric's Minecraft Server - Map</title>
  <link rel="stylesheet" href="styles/style.css">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
  <style>
    /* Use flex layout for full-page design */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      display: flex;
      flex-direction: column;
    }
    header, footer {
      flex: 0 0 auto;
    }
    main {
      flex: 1 1 auto;
      position: relative;
    }
    /* Map container fills main */
    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
    /* Prevent image smoothing (ideal for pixel art) */
    .leaflet-tile,
    .leaflet-image-layer {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      -ms-interpolation-mode: nearest-neighbor;
    }
  </style>
</head>
<body>
  <header>
    <h1>Welcome to Eric's Minecraft Server</h1>
    <nav>
      <div class="nav-buttons">
        <button onclick="window.location.href='index.html'">Home</button>
        <button onclick="window.location.href='news.html'">News</button>
        <button onclick="window.location.href='gallery.html'">Gallery</button>
        <button onclick="window.location.href='map.html'">Map</button>
        <button onclick="window.location.href='instructions.html'">Instructions</button>
        <button onclick="window.location.href='upcoming.html'">Upcoming</button>
      </div>
    </nav>
  </header>
  <main>
    <div id="map"></div>
  </main>
  <footer>
    <p>&copy; 2024 Eric's Minecraft Server</p>
  </footer>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // Load the JSON file generated by your Python script.
    fetch('tiles_bounds.json')
      .then(response => response.json())
      .then(data => {
        console.log("Loaded JSON:", data);
        const minX = data.minX;   // e.g., -4
        const maxX = data.maxX;   // e.g., -2
        const minY = data.minY;   // e.g., 0
        const maxY = data.maxY;   // e.g., 4
        const tileWidth = data.tileWidth;   // e.g., 512
        const tileHeight = data.tileHeight; // e.g., 512
        const tiles = data.tiles; // Array of available tile objects

        // Compute grid dimensions from the bounding box.
        const worldColumns = maxX - minX + 1;  // e.g., 3 columns
        const worldRows = maxY - minY + 1;     // e.g., 5 rows
        const worldWidth = worldColumns * tileWidth;   // e.g., 3*512 = 1536
        const worldHeight = worldRows * tileHeight;      // e.g., 5*512 = 2560
        console.log("World dimensions (px):", worldWidth, "x", worldHeight);

        // Define map bounds (in pixel space) before any transformation.
        const mapBounds = [[0, 0], [worldHeight, worldWidth]];
        console.log("Map bounds:", mapBounds);

        // Initialize the map using the default L.CRS.Simple.
        const map = L.map('map', {
          crs: L.CRS.Simple,
          center: [worldHeight / 2, worldWidth / 2],  // Leaflet expects [y, x]
          zoom: 0,
          minZoom: -2,  // Allow more zoom-out
          maxZoom: 4,
          maxBounds: mapBounds,
          noWrap: true
        });
        map.fitBounds(mapBounds);
        console.log("Map center:", map.getCenter(), "Zoom:", map.getZoom());

        // Assume your tile y-coordinates follow TMS order.
        // Compute vertical grid index by flipping:
        // gridX = fileX - minX (unchanged)
        // gridY_TMS = (worldRows - 1) - (fileY - minY)
        const worldRowsCount = worldRows;
        tiles.forEach(tile => {
          const fileX = tile.x;
          const fileY = tile.y;
          const gridX = fileX - minX;
          const gridY_standard = fileY - minY;
          const gridY_TMS = (worldRowsCount - 1) - gridY_standard;
          
          // Compute overlay bounds:
          // Top-left:     [ gridY_TMS * tileHeight, gridX * tileWidth ]
          // Bottom-right: [ (gridY_TMS + 1) * tileHeight, (gridX + 1) * tileWidth ]
          const topLeft = [ gridY_TMS * tileHeight, gridX * tileWidth ];
          const bottomRight = [ (gridY_TMS + 1) * tileHeight, (gridX + 1) * tileWidth ];
          const overlayBounds = [ topLeft, bottomRight ];
          
          const url = 'journeymap/' + fileX + ',' + fileY + '.png';
          console.log("Adding tile", fileX + "," + fileY, "with bounds", overlayBounds, "URL:", url);
          
          L.imageOverlay(url, overlayBounds).addTo(map);
        });
      })
      .catch(error => {
        console.error("Error loading JSON:", error);
      });
  </script>
</body>
</html>
